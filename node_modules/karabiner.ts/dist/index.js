let G = [
  "left_control",
  "left_shift",
  "left_option",
  "left_command",
  "right_control",
  "right_shift",
  "right_option",
  "right_command",
  "fn"
], ve = [...G, "caps_lock"], Me = [
  "return_or_enter",
  "escape",
  "delete_or_backspace",
  "delete_forward",
  "tab",
  "spacebar",
  "hyphen",
  "equal_sign",
  "open_bracket",
  "close_bracket",
  "backslash",
  "non_us_pound",
  "semicolon",
  "quote",
  "grave_accent_and_tilde",
  "comma",
  "period",
  "slash",
  "non_us_backslash"
], Ce = [
  "up_arrow",
  "down_arrow",
  "left_arrow",
  "right_arrow",
  "page_up",
  "page_down",
  "home",
  "end"
], Ee = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
], Ae = [
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "0"
], Te = [
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "f10",
  "f11",
  "f12",
  "f13",
  "f14",
  "f15",
  "f16",
  "f17",
  "f18",
  "f19",
  "f20"
], Ke = [
  "keypad_num_lock",
  "keypad_slash",
  "keypad_asterisk",
  "keypad_hyphen",
  "keypad_plus",
  "keypad_enter",
  "keypad_1",
  "keypad_2",
  "keypad_3",
  "keypad_4",
  "keypad_5",
  "keypad_6",
  "keypad_7",
  "keypad_8",
  "keypad_9",
  "keypad_0",
  "keypad_period",
  "keypad_equal_sign",
  "keypad_comma"
], Se = [
  "print_screen",
  "scroll_lock",
  "pause",
  "insert",
  "application",
  "help",
  "power"
], $e = [
  "international1",
  "international3",
  "lang1",
  "lang2"
], De = ["japanese_eisuu", "japanese_kana"], Oe = [
  "volume_down",
  // equal to `volume_decrement`
  "volume_up",
  // equal to `volume_increment`
  "mute",
  "volume_decrement",
  "volume_increment"
], Q = [
  // Function keys
  "f21",
  "f22",
  "f23",
  "f24",
  // Keys in pc keyboards
  "execute",
  "menu",
  "select",
  "stop",
  "again",
  "undo",
  "cut",
  "copy",
  "paste",
  "find",
  // International keys
  "international2",
  "international4",
  "international5",
  "international6",
  "international7",
  "international8",
  "international9",
  "lang3",
  "lang4",
  "lang5",
  "lang6",
  "lang7",
  "lang8",
  "lang9",
  // Japanese
  "japanese_pc_nfer",
  // PCキーボードの無変換キー
  "japanese_pc_xfer",
  // PCキーボードの変換キー
  "japanese_pc_katakana",
  // PCキーボードのかなキー
  // Others
  "keypad_equal_sign_as400",
  "locking_caps_lock",
  "locking_num_lock",
  "locking_scroll_lock",
  "alternate_erase",
  "sys_req_or_attention",
  "cancel",
  "clear",
  "prior",
  "return",
  // rarely used return (HID usage 0x9e)
  "separator",
  "out",
  "oper",
  "clear_or_again",
  "cr_sel_or_props",
  "ex_sel"
], F = [
  // Disable this key
  "vk_none",
  // Others
  "vk_consumer_brightness_down",
  // equal to `display_brightness_decrement`
  "vk_consumer_brightness_up",
  // equal to `display_brightness_increment`
  "vk_mission_control",
  // equal to `mission_control`
  "vk_launchpad",
  // equal to `launchpad`
  "vk_dashboard",
  // equal to `dashboard`
  "vk_consumer_illumination_down",
  // equal to `illumination_decrement`
  "vk_consumer_illumination_up",
  // equal to `illumination_increment`
  "vk_consumer_previous",
  // equal to `rewind`
  "vk_consumer_play",
  // equal to `play`
  "vk_consumer_next",
  // equal to `fast_forward`
  "display_brightness_decrement",
  "display_brightness_increment",
  "rewind",
  "play_or_pause",
  "fastforward",
  "apple_display_brightness_decrement",
  "apple_display_brightness_increment",
  "dashboard",
  "launchpad",
  "mission_control",
  "apple_top_case_display_brightness_decrement",
  "apple_top_case_display_brightness_increment",
  "illumination_decrement",
  "illumination_increment"
], $t = [
  // Media controls
  "rewind",
  "play_or_pause",
  "fast_forward",
  "mute",
  "volume_decrement",
  "volume_increment",
  "al_terminal_lock_or_screensaver",
  // Lock key on Magic Keyboard without Touch ID
  "eject",
  "scan_previous_track",
  "scan_next_track",
  // Application Launch keys
  "al_word_processor",
  "al_text_editor",
  "al_spreadsheet",
  "al_presentation_app",
  "al_email_reader",
  "al_calculator",
  "al_local_machine_browser",
  "al_internet_browser",
  "al_dictionary",
  // Others
  "fastforward"
], Dt = [
  // Media controls
  "menu",
  // Touch ID on Magic Keyboard
  // Application Launch keys
  "al_graphics_editor",
  "al_database_app",
  "al_newsreader",
  "al_voicemail",
  "al_contacts_or_address_book",
  "al_Calendar_Or_Schedule",
  "al_task_or_project_manager",
  "al_log_or_journal_or_timecard",
  "al_checkbook_or_finance",
  "al_a_or_v_capture_or_playback",
  "al_lan_or_wan_browser",
  "al_remote_networking_or_isp_connect",
  "al_network_conference",
  "al_network_chat",
  "al_telephony_or_dialer",
  "al_logon",
  "al_logoff",
  "al_logon_or_logoff",
  "al_control_panel",
  "al_command_line_processor_or_run",
  "al_process_or_task_manager",
  "al_select_task_or_application",
  "al_next_task_or_application",
  "al_previous_task_or_application",
  "al_preemptive_halt_task_or_application",
  "al_integrated_help_center",
  "al_documents",
  "al_thesaurus",
  "al_desktop",
  "al_spell_check",
  "al_grammer_check",
  "al_wireless_status",
  "al_keyboard_layout",
  "al_virus_protection",
  "al_encryption",
  "al_screen_saver",
  "al_alarms",
  "al_clock",
  "al_file_browser",
  "al_power_status",
  "al_image_browser",
  "al_audio_browser",
  "al_movie_browser",
  "al_digital_rights_manager",
  "al_digital_wallet",
  "al_instant_messaging",
  "al_oem_feature_browser",
  "al_oem_help",
  "al_online_community",
  "al_entertainment_content_browser",
  "al_online_shopping_browswer",
  "al_smart_card_information_or_help",
  "al_market_monitor_or_finance_browser",
  "al_customized_corporate_news_browser",
  "al_online_activity_browswer",
  "al_research_or_search_browswer",
  "al_audio_player",
  "al_message_status",
  "al_contact_sync",
  "al_navigation",
  "al_contextaware_desktop_assistant",
  // Generic GUI application Control keys
  "ac_home",
  "ac_back",
  "ac_forward",
  "ac_refresh",
  "ac_bookmarks",
  // Remote control buttons
  "menu_pick",
  "menu_up",
  "menu_down",
  "menu_left",
  "menu_right",
  "menu_escape",
  "menu_value_increase",
  "menu_value_decrease",
  "data_on_screen",
  "closed_caption",
  "closed_caption_select",
  "vcr_or_tv",
  "broadcast_mode",
  "snapshot",
  "still",
  "picture_in_picture_toggle",
  "picture_in_picture_swap",
  "red_menu_button",
  "green_menu_button",
  "blue_menu_button",
  "yellow_menu_button",
  "aspect",
  "three_dimensional_mode_select"
], Ot = [
  // Media controls
  "display_brightness_decrement",
  "display_brightness_increment",
  "dictation"
], jt = [
  "button1",
  "button2",
  "button3",
  "button4",
  "button5",
  "button6",
  "button7",
  "button8",
  "button9",
  "button10",
  "button11",
  "button12",
  "button13",
  "button14",
  "button15",
  "button16",
  "button17",
  "button18",
  "button19",
  "button20",
  "button21",
  "button22",
  "button23",
  "button24",
  "button25",
  "button26",
  "button27",
  "button28",
  "button29",
  "button30",
  "button31",
  "button32"
], N = {
  "⌘": "command",
  "⌥": "option",
  "⌃": "control",
  "⇧": "shift",
  "⇪": "caps_lock"
}, pe = {
  "↑": "up_arrow",
  "↓": "down_arrow",
  "←": "left_arrow",
  "→": "right_arrow",
  "⇞": "page_up",
  "⇟": "page_down",
  "↖︎": "home",
  "↘︎": "end"
}, he = {
  "⏎": "return_or_enter",
  "⎋": "escape",
  "⌫": "delete_or_backspace",
  "⌦": "delete_forward",
  "⇥": "tab",
  "␣": "spacebar",
  "-": "hyphen",
  "=": "equal_sign",
  "[": "open_bracket",
  "]": "close_bracket",
  "\\": "backslash",
  ";": "semicolon",
  "'": "quote",
  "`": "grave_accent_and_tilde",
  ",": "comma",
  ".": "period",
  "/": "slash"
}, ne = {
  ...pe,
  ...he,
  "⇪": N["⇪"]
}, je = [
  ...G,
  ...ve,
  ...Me,
  ...Ce,
  ...Ee,
  ...Ae,
  ...Te,
  ...Ke,
  ...Se,
  ...$e,
  ...De,
  ...Oe,
  ...Q,
  ...F
];
function S(t, e, i) {
  if (typeof t == "number") return `${t}`;
  if (t.length > 1 && X(t)) {
    let r = te(t);
    if ((r == null ? void 0 : r.length) == 1)
      return r[0];
    throw new Error(`Invalid key ${t}`);
  }
  if (t in ne)
    return ne[t];
  let o = t;
  if (!je.includes(o))
    throw new Error(`${o} is not valid key_code`);
  if (e != null && e.includes(o))
    throw new Error(`Key ${t} cannot be used ${i || "here"}`);
  return o;
}
let Pe = {
  Meh: ["command", "option", "shift"],
  Hyper: ["command", "option", "control"],
  Super: ["command", "option", "control", "shift"]
}, ae = {
  "⌘⇧": ["command", "shift"],
  "⌥⇧": ["option", "shift"],
  "⌃⇧": ["control", "shift"],
  "⌘⌥": ["command", "option"],
  "⌘⌃": ["command", "control"],
  "⌥⌃": ["option", "control"],
  "⌘⌥⌃": ["command", "option", "control"],
  "⌘⌥⇧": ["command", "option", "shift"],
  "⌘⌃⇧": ["command", "control", "shift"],
  "⌥⌃⇧": ["option", "control", "shift"],
  "⌘⌥⌃⇧": ["command", "option", "control", "shift"],
  ...Pe
};
function A(t) {
  if (!t) return;
  if (typeof t == "string")
    return X(t) ? te(t) : t in N ? [N[t]] : t in ae ? ae[t] : [t];
  if (Array.isArray(t))
    return Le(t) ? Ie(t) : t.map(Be);
  let e;
  "left" in t ? e = O("left", t.left) : "l" in t && (e = O("left", t.l));
  let i;
  if ("right" in t ? i = O("right", t.right) : "r" in t && (i = O("right", t.r)), !(!(e != null && e.length) && !(i != null && i.length)))
    return [...e || [], ...i || []];
}
let me = /^(left|l|<|‹)([⌘⌥⌃⇧]*)$/, ye = /^(right|r|>|›)([⌘⌥⌃⇧]*)$/;
function B(t, e) {
  if (!(!t && !e))
    return {
      mandatory: se(t),
      optional: se(e)
    };
}
function se(t) {
  if (t)
    return t == "any" ? ["any"] : A(t);
}
let Ve = /* @__PURE__ */ new Set([
  "command",
  "option",
  "control",
  "shift"
]);
function X(t) {
  return me.test(t) || ye.test(t);
}
function te(t) {
  let e = t.match(me);
  if (e)
    return O("left", e[2]);
  let i = t.match(ye);
  if (i)
    return O("right", i[2]);
}
function Le(t) {
  return t.some(X);
}
function Ie(t) {
  return t.reduce(
    (e, i) => [
      ...e,
      ...X(i) ? te(i) || [] : A(i) || []
    ],
    []
  );
}
function O(t, e) {
  var i;
  if (e)
    return (i = A(e)) == null ? void 0 : i.map(
      (o) => Ve.has(o) ? `${t}_${o}` : o
    );
}
function Be(t) {
  return t in N ? N[t] : t;
}
function v(t) {
  return Array.isArray(t) ? t : [t];
}
function g(t, e = 1, i) {
  return new M({ type: "variable_if", name: t, value: e, description: i });
}
function Pt(t, e) {
  var o, r;
  let i;
  if (Array.isArray(t))
    i = t.map(J);
  else if (typeof t == "string" || t instanceof RegExp)
    i = [J(t)];
  else
    return new M({
      type: "frontmost_application_if",
      description: e,
      file_paths: (o = t.file_paths) == null ? void 0 : o.map(J),
      bundle_identifiers: (r = t.bundle_identifiers) == null ? void 0 : r.map(J)
    });
  return new M({
    type: "frontmost_application_if",
    description: e,
    bundle_identifiers: i
  });
}
function Vt(t, e) {
  return new M({
    type: "device_if",
    identifiers: v(t),
    description: e
  });
}
function Lt(t, e) {
  return new M({
    type: "device_exists_if",
    identifiers: v(t),
    description: e
  });
}
function It(t, e) {
  return new M({
    type: "keyboard_type_if",
    keyboard_types: v(t),
    description: e
  });
}
function Bt(t, e) {
  return new M({
    type: "input_source_if",
    input_sources: v(t),
    description: e
  });
}
function Nt(t = !0, e) {
  return new M({ type: "event_changed_if", value: t, description: e });
}
let Ne = Re({
  frontmost_application_if: "frontmost_application_unless",
  device_if: "device_unless",
  device_exists_if: "device_exists_unless",
  keyboard_type_if: "keyboard_type_unless",
  input_source_if: "input_source_unless",
  variable_if: "variable_unless",
  event_changed_if: "event_changed_unless"
});
class M {
  constructor(e) {
    this.condition = e;
  }
  /** Switch type {condition}_if to {condition}_unless, and vice versa */
  unless() {
    return new M({
      ...this.condition,
      type: Ne[this.condition.type]
    });
  }
  build() {
    return { ...this.condition };
  }
}
function qe(t) {
  return typeof t.build == "function";
}
function $(t) {
  return qe(t) ? t.build() : t;
}
function J(t) {
  return typeof t == "string" ? t : t.toString().slice(1, -1);
}
function Re(t) {
  return Object.keys(t).reduce(
    (e, i) => ({ ...e, [e[i]]: i }),
    t
  );
}
let Fe = ["optionalAny", "?any", "??"];
function He(t) {
  return !t || typeof t != "string" ? !1 : Fe.includes(t);
}
function Ue(t) {
  return /^\?(left|l|<|‹|right|r|>|›)?([⌘⌥⌃⇧⇪]*)$/.test(t);
}
function k(t, e) {
  if (!t)
    return B(t, e);
  if (He(t))
    return B("", "any");
  if (typeof t == "string") {
    if (Ue(t))
      return B(
        "",
        A(t.slice(1))
      );
    if (t.startsWith("?"))
      throw new Error(`${t} is not valid optional alias`);
  }
  return typeof t == "object" && "optional" in t ? B("", t.optional) : B(t, e);
}
function q(t, e, i) {
  if (typeof t == "object")
    return new P(t);
  let o = S(
    t,
    F,
    "for from.key_code"
  );
  return new P({
    key_code: o,
    modifiers: k(e, i)
  });
}
function qt(t, e, i) {
  return new P({
    consumer_key_code: t,
    modifiers: k(e, i)
  });
}
function Rt(t, e, i) {
  return new P({
    pointing_button: t,
    modifiers: k(e, i)
  });
}
function b(t, e, i) {
  let o = S(
    t,
    Q,
    "as to.key_code"
  );
  return {
    ...i,
    key_code: o,
    modifiers: e ? A(e) : void 0
  };
}
function Je(t) {
  return b("left_command", "⌥⌃⇧", t);
}
function xe(t) {
  return b("left_option", "⌃⇧", t);
}
function ze(t) {
  return b("fn", "⌘⌥⌃⇧", t);
}
function We(t) {
  return b("vk_none", void 0, t);
}
function Ge(t, e, i) {
  return {
    ...i,
    consumer_key_code: t,
    modifiers: e ? A(e) : void 0
  };
}
function Qe(t, e, i) {
  return {
    ...i,
    generic_desktop: t,
    modifiers: e ? A(e) : void 0
  };
}
function Xe(t, e, i) {
  return {
    ...i,
    pointing_button: t,
    modifiers: e ? A(e) : void 0
  };
}
function Y(t) {
  return { shell_command: t };
}
function Ye(t) {
  let e = t.match(/^"?(.*?)(.app)?"?$/);
  return Y(`open -a "${(e == null ? void 0 : e[1]) || t}".app`);
}
function Ze(t) {
  return Y(`osascript -e '
set prev to the clipboard
set the clipboard to "${t}"
tell application "System Events"
  keystroke "v" using command down
  delay 0.1
end tell
set the clipboard to prev'`);
}
let et = [
  "Tink",
  "Submarine",
  "Sosumi",
  "Morse",
  "Ping",
  "Pop",
  "Purr",
  "Glass",
  "Hero",
  "Frog",
  "Funk",
  "Blow",
  "Bottle",
  "Basso"
];
function Ft(t) {
  let e = et.includes(t) ? `/System/Library/Sounds/${t}.aiff` : t;
  return Y(`afplay ${e}`);
}
function tt(t) {
  return { select_input_source: t };
}
function c(t, e = 1, i, o) {
  return { set_variable: { name: t, value: e, key_up_value: i, type: o } };
}
function it(t) {
  return { set_variable: { name: t, type: "unset" } };
}
function ie(t, e) {
  return { set_notification_message: { id: t, text: e } };
}
function R(t) {
  return { set_notification_message: { id: t, text: "" } };
}
function ot(t) {
  return { mouse_key: t };
}
function rt(t, e = "toggle") {
  return { sticky_modifier: { [t]: e } };
}
function nt(t) {
  return {
    software_function: { cg_event_double_click: { button: t } }
  };
}
function at(t) {
  return { software_function: { set_mouse_cursor_position: t } };
}
function st(t) {
  return {
    software_function: {
      iokit_power_management_sleep_system: { delay_milliseconds: t }
    }
  };
}
let j = {};
for (let t = 0; t <= 9; t++)
  j[t] = b(t);
let lt = "abcdefghijklmnopqrstuvwxyz".split("");
for (let t of lt)
  j[t] = b(t), j[t.toUpperCase()] = b(t, "⇧");
let ut = [
  ...Object.keys(pe),
  ...Object.keys(he)
];
for (let t of ut)
  j[t] = b(t);
let dt = {
  1: "!",
  2: "@",
  3: "#",
  4: "$",
  5: "%",
  6: "^",
  7: "&",
  8: "*",
  9: "(",
  0: ")",
  "'": '"',
  "=": "+",
  ";": ":",
  ",": "<",
  ".": ">",
  "/": "?",
  "-": "_",
  "[": "{",
  "\\": "|",
  "]": "}",
  "`": "~"
};
for (let [t, e] of Object.entries(dt))
  j[e] = b(t, "⇧");
function _t(t, e) {
  return t.split("").map((i) => {
    let o = (e == null ? void 0 : e[i]) || j[i];
    if (!o)
      throw new Error(
        `${i} is unknown. Please provide a map with { ${i}: {ToEvent} }`
      );
    return o;
  });
}
class P {
  constructor(e) {
    this.manipulator = { type: "basic", from: e };
  }
  /** The FromEvent of the Manipulator. */
  get from() {
    return this.manipulator.from;
  }
  to(e, i, o) {
    return this.addToEvent(
      typeof e == "object" ? e : b(e, i, o)
    ), this;
  }
  /** To Hyper key ⌘⌥⌃ */
  toHyper(e) {
    return this.addToEvent(Je(e)), this;
  }
  /** To Meh key ⌘⌥⇧ */
  toMeh(e) {
    return this.addToEvent(xe(e)), this;
  }
  /** To Super key ⌘⌥⌃⇧ */
  toSuper(e) {
    return this.addToEvent(ze(e)), this;
  }
  /** To vk_none (Disable this key) */
  toNone(e) {
    return this.addToEvent(We(e)), this;
  }
  /** To { consumer_key_code } */
  toConsumerKey(e, i, o) {
    return this.addToEvent(Ge(e, i, o)), this;
  }
  /** To { generic_desktop } */
  toGenericDesktop(e, i, o) {
    return this.addToEvent(Qe(e, i, o)), this;
  }
  /** Map to mouse button */
  toPointingButton(e, i, o) {
    return this.addToEvent(Xe(e, i, o)), this;
  }
  /** Map to shell command */
  to$(e) {
    return this.addToEvent(Y(e)), this;
  }
  /** Map to `$ open -a {app}.app` */
  toApp(e) {
    return this.addToEvent(Ye(e)), this;
  }
  /** Map to paste {text} via clipboard */
  toPaste(e) {
    return this.addToEvent(Ze(e)), this;
  }
  /** To change the current input source */
  toInputSource(e) {
    return this.addToEvent(tt(e)), this;
  }
  /** Map to setting a variable */
  toVar(e, i = 1, o, r) {
    return this.addToEvent(c(e, i, o, r)), this;
  }
  /** Map to unsetting a variable */
  toUnsetVar(e) {
    return this.addToEvent(it(e)), this;
  }
  /** To set or remove (set text to '') the notification message */
  toNotificationMessage(e, i) {
    return this.addToEvent(ie(e, i)), this;
  }
  /** To remove the notification message */
  toRemoveNotificationMessage(e) {
    return this.addToEvent(R(e)), this;
  }
  /** Move mouse cursor by delta */
  toMouseKey(e) {
    return this.addToEvent(ot(e)), this;
  }
  /** Changes to a sticky modifier key */
  toStickyModifier(e, i = "toggle") {
    return this.addToEvent(rt(e, i)), this;
  }
  /** @see https://karabiner-elements.pqrs.org/docs/json/complex-modifications-manipulator-definition/to/software_function/cg_event_double_click/ */
  toCgEventDoubleClick(e) {
    return this.addToEvent(nt(e)), this;
  }
  /** Set mouse cursor position */
  toMouseCursorPosition(e) {
    return this.addToEvent(at(e)), this;
  }
  /** To causes a system sleep */
  toSleepSystem(e) {
    return this.addToEvent(st(e)), this;
  }
  /** To type a string of keys */
  toTypeSequence(e, i) {
    return this.addToEvent(_t(e, i)), this;
  }
  toIfAlone(e, i, o) {
    return this.pushOrCreateList(
      this.manipulator,
      "to_if_alone",
      typeof e == "object" ? e : b(e, i, o)
    ), this;
  }
  toIfHeldDown(e, i, o) {
    return this.pushOrCreateList(
      this.manipulator,
      "to_if_held_down",
      typeof e == "object" ? e : b(e, i, o)
    ), this;
  }
  toAfterKeyUp(e, i, o) {
    return this.pushOrCreateList(
      this.manipulator,
      "to_after_key_up",
      typeof e == "object" ? e : b(e, i, o)
    ), this;
  }
  toDelayedAction(e, i) {
    let o = this.manipulator.to_delayed_action || {
      to_if_invoked: [],
      to_if_canceled: []
    };
    return v(e).forEach((r) => o.to_if_invoked.push(r)), v(i).forEach((r) => o.to_if_canceled.push(r)), this.manipulator.to_delayed_action = o, this;
  }
  description(e) {
    return this.manipulator.description = e, this;
  }
  condition(...e) {
    let { conditions: i = [] } = this.manipulator;
    return this.manipulator.conditions = [...i, ...e.map($)], this;
  }
  parameters(e) {
    return this.manipulator.parameters = { ...this.manipulator.parameters, ...e }, this;
  }
  build(e) {
    return [{ ...this.manipulator }];
  }
  addToEvent(e) {
    this.pushOrCreateList(this.manipulator, "to", e);
  }
  pushOrCreateList(e, i, o) {
    let r = e[i] || [];
    v(o).forEach((n) => r.push(n)), Object.assign(e, { [i]: r });
  }
}
function ft(t) {
  return typeof t.build == "function";
}
function V(t, e) {
  return ft(t) ? t.build(e) : "type" in t ? [t] : Object.entries(t).reduce(
    (o, [r, n]) => [...o, ...q(r).to(n).build(e)],
    []
  );
}
function Ht(...t) {
  return (e) => {
    let i = t.map($);
    function o(s) {
      return s.type != "basic" ? s : {
        ...s,
        conditions: [...s.conditions || [], ...i]
      };
    }
    let n = (Array.isArray(e) ? e : V(e)).reduce(
      (s, d) => [...s, ...V(d).map(o)],
      []
    );
    return Object.assign(n, { build: () => n });
  };
}
function Ut(t) {
  return (e) => ({
    build: () => (Array.isArray(t) ? t.map((o, r) => [o, r]) : Object.entries(t)).reduce(
      (o, [r, n]) => [...o, ...V(e(r, n))],
      []
    )
  });
}
function Jt(t, e) {
  return (i) => ({
    build: (o) => {
      let r = k(
        t,
        e
      );
      return (Array.isArray(i) ? i : V(i)).map((s) => V(s, o)).reduce((s, d) => s.concat(d), []).map((s) => {
        var l;
        let d = Object.keys(r).reduce(
          (u, f) => {
            var h;
            if (!((h = r[f]) != null && h.length)) return u;
            let _ = /* @__PURE__ */ new Set([
              ...u[f] || [],
              ...r[f]
            ]);
            return u[f] = _.has("any") ? ["any"] : Array.from(_), u;
          },
          { ...(l = s.from) == null ? void 0 : l.modifiers }
        );
        return s.from = { ...s.from, modifiers: d }, s;
      });
    }
  });
}
function ct(t, e, i) {
  let o = (n) => S(n, F, "for from.simultaneous"), r = new pt({
    simultaneous: t.map(
      (n) => typeof n == "object" ? n : { key_code: o(n) }
    ),
    simultaneous_options: e
  });
  return i && r.parameters({
    "basic.simultaneous_threshold_milliseconds": i
  }), r;
}
class pt extends P {
  constructor(e) {
    super(e);
  }
  modifiers(e, i) {
    return this.manipulator.from.modifiers = e || i ? k(e, i) : void 0, this;
  }
}
let be = "__support__manipulator";
function ht(t) {
  return t.description = (t.description || "") + be, t;
}
function oe(t) {
  var e;
  return (e = t.description) == null ? void 0 : e.endsWith(be);
}
let le = {
  "double_tap.delay_milliseconds": 200
};
function xt(t, e, i, o) {
  let r = S(
    t,
    [...Q, ...F],
    "for double tap"
  ), n = new mt({ key_code: r });
  return o ? (n.delay(o), n.from.modifiers = k(
    e,
    i
  )) : i ? typeof i == "number" ? (n.delay(i), n.from.modifiers = k(
    e
  )) : n.from.modifiers = k(
    e,
    i
  ) : e && (typeof e == "number" ? n.delay(e) : n.from.modifiers = k(
    e
  )), n;
}
class mt extends P {
  constructor(e) {
    super(e), this.singleTapEvent = void 0;
  }
  /** Set single tap which is from key by default; null to disable */
  singleTap(e) {
    return this.singleTapEvent = e, this;
  }
  /** Set the delay parameter */
  delay(e) {
    return this.delayParam = e, this;
  }
  build(e) {
    var h, p;
    let i = (e == null ? void 0 : e.getParameters(le)) ?? le, o = this.delayParam || i["double_tap.delay_milliseconds"], r = this.from.key_code;
    if (typeof this.singleTapEvent > "u") {
      this.singleTapEvent = { key_code: r };
      let a = (h = this.manipulator.from.modifiers) == null ? void 0 : h.mandatory;
      a && (this.singleTapEvent.modifiers = a.filter(
        (m) => m != "any"
      ));
    }
    let n = this.singleTapEvent && "key_code" in this.singleTapEvent ? G.includes(this.singleTapEvent.key_code) : !1, s = ["double-tap", r];
    this.from.modifiers && [this.from.modifiers.mandatory, this.from.modifiers.optional].map((a) => a != null && a.length ? a.join(",") : "").forEach((a) => a && s.push(a));
    let d = s.join("-"), l = g(d).build(), u = g(d).unless().build(), f = ht({
      ...this.manipulator,
      conditions: [l]
    }), _ = {
      ...this.manipulator,
      to: [
        c(d, 1),
        ...n ? [
          {
            ...this.singleTapEvent,
            lazy: this.singleTapEvent.lazy || typeof this.singleTapEvent.lazy > "u"
          }
        ] : []
      ],
      conditions: [...this.manipulator.conditions || [], u],
      to_delayed_action: {
        to_if_invoked: [
          ...this.singleTapEvent ? [this.singleTapEvent] : [],
          c(d, 0)
        ],
        to_if_canceled: [c(d, 0)]
      }
    };
    return n && !((p = _.to_if_held_down) != null && p.length) && (_.to_if_held_down = [this.singleTapEvent]), _.parameters = {
      "basic.to_if_held_down_threshold_milliseconds": o,
      "basic.to_delayed_action_delay_milliseconds": o,
      ...this.manipulator.parameters
    }, [f, _];
  }
}
function zt() {
  return new yt();
}
class yt {
  constructor() {
    this.manipulator = {
      type: "mouse_motion_to_scroll"
    };
  }
  modifiers(e, i) {
    return this.manipulator.from = {
      modifiers: k(
        e,
        i
      )
    }, this;
  }
  condition(...e) {
    let { conditions: i = [] } = this.manipulator;
    return this.manipulator.conditions = [...i, ...e.map($)], this;
  }
  options(e) {
    return this.manipulator.options = { ...this.manipulator.options, ...e }, this;
  }
  build(e) {
    return [{ ...this.manipulator }];
  }
}
function Wt(t, ...e) {
  return new Z(t, ...e);
}
class Z {
  constructor(e, ...i) {
    this.ruleDescription = e, this.manipulatorSources = [], this.allowEmptyManipulators = !1, this.conditions = i;
  }
  manipulators(e) {
    return Array.isArray(e) ? e.forEach((i) => this.manipulatorSources.push(i)) : this.manipulatorSources.push(e), this;
  }
  condition(...e) {
    return e.forEach((i) => this.conditions.push(i)), this;
  }
  description(e) {
    return this.ruleDescription = e, this;
  }
  build(e) {
    let i = {
      description: this.ruleDescription,
      manipulators: this.manipulatorSources.reduce(
        (r, n) => [...r, ...V(n, e)],
        []
      )
    };
    if (!this.allowEmptyManipulators && i.manipulators.length == 0)
      throw new Error(`"manipulators" is empty in "${i.description}"`);
    if (this.conditions.length == 0) return i;
    let o = this.conditions.map($);
    return i.manipulators = i.manipulators.map(
      (r) => r.type == "basic" && !oe(r) ? { ...r, conditions: [...r.conditions || [], ...o] } : { ...r }
    ), i;
  }
}
function bt(t) {
  return typeof t.build == "function";
}
function gt(t, e) {
  return bt(t) ? t.build(e) : t;
}
let W = {
  escape: ["escape", "caps_lock"]
};
function ge(t, e, i) {
  let o = [];
  if (!t) return o;
  for (let r of Array.isArray(t) ? t : [t]) {
    let n = q(r);
    o.push(...n.condition(e).to(i).build());
  }
  return o;
}
let ue = {
  "layer.delay_by_default": !1,
  "layer.delay_milliseconds": 200
}, ee = [
  ...F,
  ...Q,
  ...G
];
function kt(t, e, i = 1, o = 0) {
  return new vt(t, e, i, o);
}
function wt(t, e, i, o = 1, r = 0) {
  return kt(e, i, o, r).modifiers(t);
}
function Gt(t, e, i = 1, o = 0) {
  return wt("Hyper", t, e, i, o);
}
let x = "__layer", de = "__delay";
class vt extends Z {
  constructor(e, i, o = 1, r = 0) {
    let n = v(e).map(
      (s) => S(s, ee, "as layer key")
    );
    i || (i = `layer-${n.join("-")}`), super(`Layer - ${i}`), this.onValue = o, this.offValue = r, this.replaceLayerKeyToIfAlone = !1, this.delayed = void 0, this.keys = n, this.varName = i, this.layerCondition = g(this.varName, this.onValue), this.condition(this.layerCondition), this.allowEmptyManipulators = !0;
  }
  modifiers(e, i) {
    return this.layerModifiers = e || i ? k(e, i) : void 0, this;
  }
  /** Config the layer key. */
  configKey(e, i = !1) {
    return this.layerKeyManipulator || (this.layerKeyManipulator = q("fn")), e(this.layerKeyManipulator), this.replaceLayerKeyToIfAlone = i, this;
  }
  /** Set the notification when the layer is active. */
  notification(e = !0) {
    return this.layerNotification = e, this;
  }
  /** Set leader mode. Default escape keys: ['escape', 'caps_lock']. */
  leaderMode(e = !0) {
    return typeof e == "boolean" ? this.leaderModeOptions = e ? W : void 0 : this.leaderModeOptions = { ...W, ...e }, this;
  }
  /** Set delay mode (and delay_milliseconds). */
  delay(e = !0) {
    return this.delayed = e, this;
  }
  build(e) {
    var r, n, s, d;
    let i = super.build(e);
    if (this.leaderModeOptions) {
      let l = [
        c(this.varName, this.offValue),
        c(x, 0)
      ];
      this.layerNotification && l.push(R(we(this.varName))), this.leaderModeOptions.sticky || i.manipulators.forEach(
        (u) => u.type == "basic" && !oe(u) && (u.to = (u.to || []).concat(l))
      ), i.manipulators.push(
        ...ge(
          this.leaderModeOptions.escape,
          g(this.varName, this.onValue),
          l
        )
      );
    }
    if ((n = (r = this.layerModifiers) == null ? void 0 : r.mandatory) != null && n.length || (d = (s = this.layerModifiers) == null ? void 0 : s.optional) != null && d.length) {
      let l = _e(this.layerModifiers) == "optional";
      i.manipulators.forEach(
        (u) => this.addModifierAnyToManipulator(u, l)
      );
    }
    let o = this.conditions.filter((l) => l != this.layerCondition).map($);
    for (let l of this.keys)
      i.manipulators = [
        ...ke(
          l,
          this.varName,
          this.onValue,
          this.offValue,
          this.layerModifiers,
          o,
          e,
          this.layerKeyManipulator,
          this.replaceLayerKeyToIfAlone,
          typeof this.layerNotification == "boolean" && this.layerNotification ? this.ruleDescription : this.layerNotification || void 0,
          this.leaderModeOptions,
          this.delayed
        ),
        ...i.manipulators
      ];
    return i;
  }
  // If the layer has modifiers, set manipulator modifiers to { mandatory: ['any'] }
  addModifierAnyToManipulator(e, i) {
    if (e.type == "basic") {
      if (e.from.modifiers) {
        let { mandatory: o, optional: r } = e.from.modifiers;
        if (r != null && r.length || o != null && o.length) {
          let n = _e(e.from.modifiers);
          if (n == "mandatory")
            e.from.modifiers = { mandatory: ["any"] };
          else if (n == "optional")
            e.from.modifiers = { optional: ["any"] };
          else if (!i)
            throw new Error(
              "Layers with modifiers cannot have modifiers on manipulators"
            );
          return;
        }
      }
      e.from.modifiers = i ? { optional: ["any"] } : { mandatory: ["any"] };
    }
  }
}
function ke(t, e, i, o, r, n, s, d, l, u, f, _) {
  var I;
  function h(y) {
    var re;
    if (!d) return y;
    let D = d.build()[0], K = v(y)[0];
    if ([
      "to",
      "to_if_alone",
      "to_if_held_down",
      "to_after_key_up"
    ].forEach(
      (C) => {
        var H;
        return (H = D[C]) == null ? void 0 : H.forEach(
          (U) => K[C] = [...K[C] || [], U]
        );
      }
    ), D.to_delayed_action) {
      K.to_delayed_action = K.to_delayed_action || {
        to_if_invoked: [],
        to_if_canceled: []
      };
      for (let C of ["to_if_invoked", "to_if_canceled"])
        D.to_delayed_action[C].forEach(
          (H) => {
            var U;
            return (U = K.to_delayed_action) == null ? void 0 : U[C].push(H);
          }
        );
    }
    return l && (K.to_if_alone = (re = K.to_if_alone) == null ? void 0 : re.filter(
      (C) => !("key_code" in C && C.key_code == t)
    )), y;
  }
  let p = Mt(_, s), a = q({ key_code: t, modifiers: r }).toVar(e, p > 0 ? de : i).toVar(x).condition(
    p > 0 ? g(e, o) : g(e, i).unless(),
    g(x).unless()
  );
  !((I = r == null ? void 0 : r.mandatory) != null && I.length) && !f && a.toIfAlone({ key_code: t }), f || a.toAfterKeyUp(c(e, o)).toAfterKeyUp(c(x, 0));
  let m = g(e, de).build();
  if (p > 0 && a.toIfAlone(c(e, o)).toIfHeldDown(c(e, i)).toDelayedAction(
    [],
    [
      { key_code: t, conditions: [m] },
      {
        set_variable: { name: e, value: o },
        conditions: [m]
      }
    ]
  ).parameters({
    "basic.to_if_held_down_threshold_milliseconds": p,
    "basic.to_delayed_action_delay_milliseconds": p,
    "basic.to_if_alone_timeout_milliseconds": p
  }), n != null && n.length && a.condition(...n), u) {
    let y = we(e);
    p > 0 ? (a.toIfHeldDown(ie(y, u)), a.toDelayedAction([], {
      ...R(y),
      conditions: [m]
    })) : a.toNotificationMessage(y, u), f || a.toAfterKeyUp(R(y));
  }
  if (!s)
    return h(a.build());
  let T = [
    `layer_${t}`,
    ...r ? [JSON.stringify(r)] : [],
    ...(n || []).map((y) => JSON.stringify(y)).sort()
  ].join("_"), w = s.getCache(T);
  if (w != null && w.to && w.to_after_key_up)
    return w.to.find(
      (D) => "set_variable" in D && D.set_variable.name == e
    ) || (w.to.push(c(e, i)), w.to_after_key_up.push(c(e, o))), h(w), [];
  let L = a.build(s);
  return s.setCache(T, L[0]), h(L);
}
function _e({
  mandatory: t,
  optional: e
}) {
  return (t == null ? void 0 : t.length) == 1 && t[0] == "any" ? "mandatory" : (e == null ? void 0 : e.length) == 1 && e[0] == "any" ? "optional" : null;
}
function we(t) {
  return `layer-${t}`;
}
function Mt(t, e) {
  if (typeof t == "number") return t;
  if (t == !1) return 0;
  let i = (e == null ? void 0 : e.getParameters(ue)) ?? ue;
  return t || i["layer.delay_by_default"] ? i["layer.delay_milliseconds"] : 0;
}
let fe = {
  "simlayer.threshold_milliseconds": 200
};
function Qt(t, e, i, o = 1, r = 0) {
  return new Ct(t, e, i, o, r);
}
class Ct extends Z {
  constructor(e, i, o, r = 1, n = 0) {
    let s = v(e).map(
      (d) => S(d, ee, "as simlayer key")
    );
    i || (i = `simlayer-${s.join("-")}`), super(`Simlayer - ${i}`), this.threshold = o, this.onValue = r, this.offValue = n, this.sharedLayerKeys = [], this.simultaneousOptions = {
      detect_key_down_uninterruptedly: !0,
      key_down_order: "strict",
      key_up_order: "strict_inverse",
      key_up_when: "any"
    }, this.layerModifiers = { optional: ["any"] }, this.ifActivated = [], this.ifDeactivated = [], this.keys = s, this.varName = i, this.layerCondition = g(this.varName, this.onValue), this.condition(this.layerCondition);
  }
  modifiers(e, i) {
    return this.layerModifiers = e || i ? k(e, i) : void 0, this;
  }
  /** Set simultaneous_options on the simlayer toggle manipulator */
  options(e) {
    return Object.assign(this.simultaneousOptions, e), this;
  }
  /** Enable layer with the same variable and manipulators with this simlayer */
  enableLayer(...e) {
    return e.map(
      (i) => S(i, ee, "as layer key")
    ).forEach((i) => {
      if (this.keys.includes(i))
        throw new Error(`Key ${i} is already used in ${this.ruleDescription}`);
      if (this.sharedLayerKeys.includes(i))
        throw new Error(
          `Key ${i} is already used as shared layer key in  ${this.ruleDescription}`
        );
      this.sharedLayerKeys.push(i);
    }), this;
  }
  /** The ToEvents to trigger when the layer is activated */
  toIfActivated(e) {
    return this.ifActivated.push(e), this;
  }
  /** The ToEvents to trigger when the layer is deactivated */
  toIfDeactivated(e) {
    return this.ifDeactivated.push(e), this;
  }
  build(e) {
    let i = super.build(e), o = (e == null ? void 0 : e.getParameters(fe)) ?? fe, r = this.threshold || o["simlayer.threshold_milliseconds"], n = this.conditions.length > 1 ? this.conditions.filter((l) => l != this.layerCondition).map($) : void 0, s = c(this.varName, this.onValue), d = c(this.varName, this.offValue);
    i.manipulators.concat().forEach((l) => {
      var f;
      if (l.type != "basic")
        throw new Error(
          `Unsupported manipulator type ${l.type} in simlayer ${this.ruleDescription}`
        );
      let u = (f = l.from) == null ? void 0 : f.key_code;
      if (!u)
        throw new Error(
          `Missing from.key_code in simlayer ${this.ruleDescription}`
        );
      this.layerModifiers && (l.from.modifiers = {
        ...l.from.modifiers,
        ...this.layerModifiers
      });
      for (let _ of this.keys)
        i.manipulators.push({
          type: "basic",
          parameters: {
            "basic.simultaneous_threshold_milliseconds": r
          },
          to: [s, ...l.to || [], ...this.ifActivated],
          from: {
            simultaneous: [{ key_code: _ }, { key_code: u }],
            simultaneous_options: {
              ...this.simultaneousOptions,
              to_after_key_up: [
                ...this.simultaneousOptions.to_after_key_up || [],
                d,
                ...this.ifDeactivated
              ]
            },
            modifiers: this.layerModifiers
          },
          conditions: n
        });
    });
    for (let l of this.sharedLayerKeys)
      i.manipulators = [
        ...ke(
          l,
          this.varName,
          this.onValue,
          this.offValue,
          this.layerModifiers,
          n,
          e
        ),
        ...i.manipulators
      ];
    return i;
  }
}
let ce = {
  "duo_layer.threshold_milliseconds": 200,
  "duo_layer.notification": !1,
  "duo_layer.delay_by_default": !1,
  "duo_layer.delay_milliseconds": 200
};
function Xt(t, e, i, o = 1, r = 0) {
  return new Et(t, e, i, o, r);
}
class Et extends Z {
  constructor(e, i, o, r = 1, n = 0) {
    let s = `DuoLayer ${o || `${e} ${i}`}`;
    o || (o = `duo-layer-${e}-${i}`), super(s), this.key1 = e, this.key2 = i, this.onValue = r, this.offValue = n, this.simultaneousOptions = {}, this.ifActivated = [], this.ifDeactivated = [], this.delayed = void 0, this.varName = o, this.layerCondition = g(this.varName, this.onValue), this.condition(this.layerCondition), this.allowEmptyManipulators = !0;
  }
  threshold(e) {
    return this.simultaneousThreshold = e, this;
  }
  options(e) {
    return Object.assign(this.simultaneousOptions, e), this;
  }
  /** Set the notification when the layer is active. */
  notification(e = !0) {
    return this.layerNotification = e, this;
  }
  /** The ToEvents to trigger when the layer is activated */
  toIfActivated(e) {
    return this.ifActivated.push(e), this;
  }
  /** The ToEvents to trigger when the layer is deactivated */
  toIfDeactivated(e) {
    return this.ifDeactivated.push(e), this;
  }
  /** Set leader mode. Default escape keys: ['escape', 'caps_lock']. */
  leaderMode(e = !0) {
    return typeof e == "boolean" ? this.leaderModeOptions = e ? W : void 0 : this.leaderModeOptions = { ...W, ...e }, this;
  }
  /** Set delay mode (and delay_milliseconds). */
  delay(e = !0) {
    return this.delayed = e, this;
  }
  build(e) {
    let i = super.build(e), o = (e == null ? void 0 : e.getParameters(ce)) ?? ce, r = this.simultaneousThreshold || o["duo_layer.threshold_milliseconds"], n = this.layerNotification ?? o["duo_layer.notification"], s = typeof this.delayed == "number" ? this.delayed : this.delayed == !1 ? 0 : this.delayed == !0 || o["duo_layer.delay_by_default"] ? o["duo_layer.delay_milliseconds"] : 0, d = this.conditions.filter((a) => a != this.layerCondition).map($), l = [c(this.varName, this.onValue), ...this.ifActivated], u = [
      c(this.varName, this.offValue),
      ...this.ifDeactivated
    ];
    if (n) {
      let a = `duo-layer-${this.varName}`, m = typeof n == "boolean" ? this.ruleDescription : n;
      l.push(ie(a, m)), u.push(R(a));
    }
    this.leaderModeOptions && (this.leaderModeOptions.sticky || i.manipulators.forEach(
      (a) => a.type == "basic" && !oe(a) && (a.to = (a.to || []).concat(u))
    ), i.manipulators.push(
      ...ge(
        this.leaderModeOptions.escape,
        g(this.varName, this.onValue),
        u
      )
    ));
    let f = this.simultaneousOptions.to_after_key_up || [];
    this.leaderModeOptions || f.push(...u);
    let _ = [
      [this.key1, this.key2],
      ...s > 0 ? [[this.key2, this.key1]] : []
    ].map((a) => {
      let m = ct(
        a,
        {
          ...this.simultaneousOptions,
          ...s > 0 ? { key_down_order: "strict" } : {},
          to_after_key_up: f
        },
        r
      ).modifiers("??").condition(g(this.varName, this.onValue).unless());
      return d.length && m.condition(...d), s > 0 ? m.toIfHeldDown(l).toIfAlone(a.map((T) => b(T))).parameters({
        "basic.to_if_held_down_threshold_milliseconds": s,
        "basic.to_if_alone_timeout_milliseconds": s
      }) : m.to(l), m;
    });
    if (!e)
      return i.manipulators = [
        ..._.flatMap((a) => a.build()),
        ...i.manipulators
      ], i;
    let h = [
      "duo_layer",
      ...[this.key1, this.key2].sort(),
      ...d.map((a) => JSON.stringify(a)).sort()
    ].join("_"), p = e.getCache(h);
    if (p)
      p.forEach((a) => {
        var T, w, L, I;
        ((T = a.to) == null ? void 0 : T.find(
          (y) => "set_variable" in y && y.set_variable.name == this.varName
        )) || ((w = a.to) == null || w.push(c(this.varName, this.onValue)), (I = (L = a.from.simultaneous_options) == null ? void 0 : L.to_after_key_up) == null || I.push(
          c(this.varName, this.offValue)
        ));
      });
    else {
      let a = _.flatMap((m) => m.build(e));
      e.setCache(h, a), i.manipulators = [...a, ...i.manipulators];
    }
    return i;
  }
}
class At {
  constructor() {
    this.parameters = {}, this.cache = /* @__PURE__ */ new Map();
  }
  setParameters(e) {
    Object.assign(this.parameters, e);
  }
  getParameters(e) {
    let i = { ...e };
    for (let o of Object.keys(e))
      o in this.parameters && this.parameters[o] != null && Object.assign(i, { [o]: this.parameters[o] });
    return i;
  }
  getCache(e) {
    return this.cache.get(e);
  }
  setCache(e, i) {
    this.cache.set(e, i);
  }
}
let Tt = {
  "basic.to_if_alone_timeout_milliseconds": 1e3,
  "basic.to_if_held_down_threshold_milliseconds": 500,
  "basic.to_delayed_action_delay_milliseconds": 500,
  "basic.simultaneous_threshold_milliseconds": 50,
  "mouse_motion_to_scroll.speed": 100
};
function Kt(t, e = {}) {
  let {
    "double_tap.delay_milliseconds": i,
    "layer.delay_by_default": o,
    "layer.delay_milliseconds": r,
    "simlayer.threshold_milliseconds": n,
    "duo_layer.threshold_milliseconds": s,
    "duo_layer.notification": d,
    "duo_layer.delay_by_default": l,
    "duo_layer.delay_milliseconds": u,
    ...f
  } = e, _ = new At();
  _.setParameters({
    "double_tap.delay_milliseconds": i
  }), _.setParameters({
    "layer.delay_by_default": o,
    "layer.delay_milliseconds": r
  }), _.setParameters({
    "simlayer.threshold_milliseconds": n
  }), _.setParameters({
    "duo_layer.threshold_milliseconds": s,
    "duo_layer.notification": d,
    "duo_layer.delay_by_default": l,
    "duo_layer.delay_milliseconds": u
  });
  let h = t.map((a) => gt(a, _)), p = {
    rules: h.filter((a) => a.manipulators.length),
    parameters: {
      ...Tt,
      ...f
    }
  };
  if (p.rules.length == 0)
    throw new Error('complex_modifications "rules" is empty ');
  return p.rules.length < h.length && console.warn(`Rules with empty manipulators are ignored:
${h.filter((a) => a.manipulators.length == 0).map((a) => "- " + a.description).join(`
`)}
`), p;
}
let E = {
  karabinerConfigDir() {
    return require("node:path").join(
      require("node:os").homedir(),
      ".config/karabiner"
    );
  },
  karabinerConfigFile() {
    return require("node:path").join(
      this.karabinerConfigDir(),
      "karabiner.json"
    );
  },
  readKarabinerConfig(t) {
    return require(t ?? this.karabinerConfigFile());
  },
  writeKarabinerConfig(t, e) {
    return require("node:fs/promises").writeFile(
      e ?? this.karabinerConfigFile(),
      t
    );
  },
  readJson(t) {
    return require(t);
  },
  exit(t = 0) {
    process.exit(t);
  }
};
function Yt(t, e, i = {}) {
  typeof t == "string" && (t = { name: t, dryRun: t == "--dry-run" });
  let { name: o, dryRun: r } = t, n = t.karabinerJsonPath ?? E.karabinerConfigFile(), s = r ? { profiles: [{ name: o, complex_modifications: { rules: [] } }] } : E.readKarabinerConfig(n), d = s == null ? void 0 : s.profiles.find((u) => u.name == o);
  d || z(`⚠️ Profile ${o} not found in ${n}.

ℹ️ Please check the profile name in the Karabiner-Elements UI and
    - Update the profile name at writeToProfile()
    - Create a new profile if needed
 `);
  try {
    d.complex_modifications = Kt(e, i);
  } catch (u) {
    z(u);
  }
  let l = JSON.stringify(s, null, 2);
  if (r) {
    console.info(l);
    return;
  }
  E.writeKarabinerConfig(l, n).catch(z), console.log(`✓ Profile ${o} updated.`);
}
function z(t) {
  return t && console.error(typeof t == "string" ? t : t.message || t), E.exit(1);
}
function Zt(t, e) {
  let i = e ?? E.karabinerConfigFile(), o = E.readKarabinerConfig(i);
  o.global = { ...o.global, ...t };
  let r = JSON.stringify(o, null, 2);
  E.writeKarabinerConfig(r, i).catch(z), console.log("✓ global updated.");
}
function ei(t) {
  return {
    build() {
      let e = E.readJson(t);
      if (!Array.isArray(e == null ? void 0 : e.rules))
        throw new Error(`Cannot file rules in ${t}`);
      return {
        description: `Imported from ${t}`,
        manipulators: e.rules.reduce(
          (i, o) => i.concat(o.manipulators),
          []
        )
      };
    }
  };
}
function ti(t, e) {
  return {
    build() {
      let o = E.readKarabinerConfig(e).profiles.find((r) => r.name == t);
      if (!o) throw new Error(`Profile ${t} not found`);
      return {
        description: `Imported from profile ${t}`,
        manipulators: o.complex_modifications.rules.reduce(
          (r, n) => r.concat(n.manipulators),
          []
        )
      };
    }
  };
}
export {
  pe as arrowKeyAliases,
  Ce as arrowKeyCodes, P as BasicManipulatorBuilder, $ as buildCondition,
  Kt as complexModifications, M as ConditionBuilder, he as controlOrSymbolKeyAliases,
  Me as controlOrSymbolKeyCodes,
  Tt as defaultComplexModificationsParameters,
  le as defaultDoubleTapParameters,
  ce as defaultDuoLayerParameters,
  ue as defaultLayerParameters,
  fe as defaultSimlayerParameters,
  Xt as duoLayer,
  $t as fromAndToConsumerKeyCodes,
  Dt as fromOnlyConsumerKeyCodes,
  Q as fromOnlyKeyCodes,
  Te as functionKeyCodes,
  S as getKeyWithAlias,
  Gt as hyperLayer,
  Pt as ifApp,
  Vt as ifDevice,
  Lt as ifDeviceExists,
  Nt as ifEventChanged,
  Bt as ifInputSource,
  It as ifKeyboardType,
  g as ifVar,
  ei as importJson,
  ti as importProfile,
  $e as internationalKeyCodes,
  qe as isConditionBuilder,
  X as isSideMultiModifierAlias,
  De as japaneseKeyCodes,
  Ke as keypadKeyCodes,
  kt as layer,
  Ee as letterKeyCodes,
  q as map,
  qt as mapConsumerKey,
  xt as mapDoubleTap,
  Rt as mapPointingButton,
  ct as mapSimultaneous,
  N as modifierKeyAliases,
  ve as modifierKeyCodes,
  wt as modifierLayer,
  zt as mouseMotionToScroll,
  ae as multiModifierAliases,
  Pe as namedMultiModifierAliases,
  Ae as numberKeyCodes,
  Oe as otherKeyCodes,
  B as parseFromModifierParams,
  A as parseModifierParam,
  te as parseSideMultiModifierAlias,
  Se as pcKeyboardKeyCodes,
  jt as pointingButtons,
  Wt as rule,
  Qt as simlayer,
  G as stickyModifierKeyCodes,
  et as systemSounds,
  Y as to$,
  Ye as toApp,
  nt as toCgEventDoubleClick,
  Ge as toConsumerKey,
  Qe as toGenericDesktop,
  Je as toHyper,
  tt as toInputSource,
  b as toKey,
  xe as toMeh,
  at as toMouseCursorPosition,
  ot as toMouseKey,
  We as toNone,
  ie as toNotificationMessage,
  Ot as toOnlyConsumerKeyCodes,
  F as toOnlyKeyCodes,
  Ze as toPaste,
  Ft as toPlaySound,
  Xe as toPointingButton,
  R as toRemoveNotificationMessage,
  c as toSetVar,
  st as toSleepSystem,
  rt as toStickyModifier,
  ze as toSuper,
  _t as toTypeSequence,
  it as toUnsetVar,
  Ht as withCondition,
  Ut as withMapper,
  Jt as withModifier,
  Zt as writeToGlobal,
  Yt as writeToProfile
};

