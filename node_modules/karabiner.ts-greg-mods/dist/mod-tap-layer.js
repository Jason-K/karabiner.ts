"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModTapLayerBuilder = void 0;
exports.modTapLayer = modTapLayer;
// A mod-tap layer is a hold-tap layer that activates a modifier on hold and
// adds a modifier to registered keys.
//
// Flaws:
//
// * You canâ€™t add modifiers by holding one key after another.
const karabiner_ts_1 = require("karabiner.ts");
const hold_tap_layer_1 = require("./hold-tap-layer");
class ModTapLayerBuilder {
    mod;
    hold_tap_layer_builder;
    isLazy = false;
    constructor(key, mod) {
        this.mod = mod;
        this.hold_tap_layer_builder = (0, hold_tap_layer_1.holdTapLayer)(key);
    }
    /**
     * Allows any modifiers to be used with the layer key.
     */
    allowAnyModifiers() {
        this.hold_tap_layer_builder.allowAnyModifiers();
        return this;
    }
    /**
     * Sets the description for the rule.
     */
    description(description) {
        this.hold_tap_layer_builder.description(description);
        return this;
    }
    /**
     * Sets the tapping term in milliseconds.
     *
     * The tapping term is the time in milliseconds that the key must be held
     * down in order to be fully active.
     */
    tappingTerm(tappingTermMs) {
        this.hold_tap_layer_builder.tappingTerm(tappingTermMs);
        return this;
    }
    /**
     * Sets whether the modifier should be sent lazily.
     */
    lazy(val) {
        this.isLazy = val;
        return this;
    }
    build() {
        // The user has held down the mod-tap key so trigger the modifier.
        //
        // `.toIfHeldDown(mod)` needs to be last to ensure that Karabiner holds the modifier.
        // `toSetVar` would interrupt the hold action.
        //
        return this.hold_tap_layer_builder
            .onHold(this.mod, [], { lazy: this.isLazy })
            .build();
    }
    holdOnOtherKeyPressManipulator(arg) {
        this.hold_tap_layer_builder.holdOnOtherKeyPressManipulator(arg);
        return this;
    }
    holdOnOtherKeyPressManipulators(arg) {
        this.hold_tap_layer_builder.holdOnOtherKeyPressManipulators(arg);
        return this;
    }
    /**
     * Adds hold on other key press keys to the layer.
     *
     * HOOKP keys immediately send the key with the layer's modifier.
     */
    holdOnOtherKeyPressKeys(keys) {
        for (const key of keys) {
            this.holdOnOtherKeyPressManipulator((0, karabiner_ts_1.map)(key).to(key, this.mod));
        }
        return this;
    }
    permissiveHoldManipulators(...manipulators) {
        this.hold_tap_layer_builder.permissiveHoldManipulators(...manipulators);
        return this;
    }
    /**
     * Adds a permissive hold key to the layer.
     */
    permissiveHoldKey(from) {
        this.hold_tap_layer_builder.permissiveHoldManipulator((0, karabiner_ts_1.map)(from).to(from, this.mod));
        return this;
    }
    permissiveHoldKeys(...keys) {
        for (const key of keys) {
            this.permissiveHoldKey(key);
        }
        return this;
    }
    /**
     * Adds slow keys to the layer.
     *
     * Slow keys act as normal keys when tapped before the tapping term.
     *
     * Registering a slow key is necessary, because the if-held-down event can be
     * interrupted, e.g., by a permissive-hold key.
     */
    slowKeys(keys) {
        for (const key of keys) {
            this.hold_tap_layer_builder.slowManipulators(...(0, karabiner_ts_1.map)(key).to(key, this.mod).build());
        }
        return this;
    }
    slowManipulators(...manipulators) {
        this.hold_tap_layer_builder.slowManipulators(...manipulators);
        return this;
    }
}
exports.ModTapLayerBuilder = ModTapLayerBuilder;
/**
 * Creates a builder for the mod-tap layer.
 */
function modTapLayer(key, mod) {
    return new ModTapLayerBuilder(key, mod);
}
