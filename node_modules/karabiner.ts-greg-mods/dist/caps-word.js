"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CapsWordBuilder = exports.disableCapsWordEvents = void 0;
exports.capsWordVarName = capsWordVarName;
exports.capsWordToggle = capsWordToggle;
exports.capsWordOff = capsWordOff;
exports.capsWord = capsWord;
// It's tricky that this mod relies on both the ⇪ modifier and a variable to
// track the Caps WORD mode, but I think I got all realistic cases covered.
//
// A previous version of this mod just registered all possible alphanumerics
// and added a shift to them, but that caused conflict with other layers, e.g.,
// HRM
// (https://github.com/gregorias/karabiner.ts-greg-mods/issues/3).
const karabiner_ts_1 = require("karabiner.ts");
function capsWordVarName() {
    return "caps-word";
}
const ifCapsWord = (0, karabiner_ts_1.ifVar)(capsWordVarName(), 1);
const setCapsWordVar = (0, karabiner_ts_1.toSetVar)(capsWordVarName());
const unsetCapsWordVar = (0, karabiner_ts_1.toUnsetVar)(capsWordVarName());
function withCapsLock(manipulator) {
    return (0, karabiner_ts_1.withModifier)("⇪")([manipulator]).build();
}
function withCapsWord(manipulator) {
    return (0, karabiner_ts_1.withCondition)(ifCapsWord)([manipulator]).build();
}
const withCapsLockAndCapsWord = (manipulator) => {
    return (0, karabiner_ts_1.withModifier)("⇪")((0, karabiner_ts_1.withCondition)(ifCapsWord)([manipulator])).build();
};
const capsLockToggleEvent = {
    key_code: "caps_lock",
    hold_down_milliseconds: 100,
};
/**
 * Turns the manipulator into a Caps WORD toggle.
 */
function capsWordToggle(manipulator) {
    const baseTo = manipulator.to ?? [];
    return [
        ...withCapsLockAndCapsWord({
            ...manipulator,
            to: [capsLockToggleEvent, unsetCapsWordVar].concat(baseTo),
        }),
        ...withCapsLock({ ...manipulator, to: [setCapsWordVar].concat(baseTo) }),
        {
            ...manipulator,
            to: [capsLockToggleEvent, setCapsWordVar].concat(baseTo),
        },
    ];
}
/**
 * Turns the manipulator into a Caps WORD off button.
 */
function capsWordOff(manipulator) {
    const baseTo = manipulator.to ?? [];
    return [
        ...withCapsLockAndCapsWord({
            ...manipulator,
            to: [capsLockToggleEvent, unsetCapsWordVar].concat(baseTo),
        }),
        ...withCapsWord({ ...manipulator, to: [unsetCapsWordVar].concat(baseTo) }),
    ];
}
exports.disableCapsWordEvents = [
    {
        ...capsLockToggleEvent,
        // This is heuristic, we should only press ⇪ if ⇪ is on.
        // Hopefully, we never get into a state where ⇪ is off but the variable is
        // on.
        conditions: [ifCapsWord.build()],
    },
    unsetCapsWordVar,
];
class CapsWordBuilder {
    ruleDescription = "Caps WORD";
    layerManipulators = [];
    useDefaultEscapeKeys = true;
    /**
     * Sets the description for the rule.
     */
    description(description) {
        this.ruleDescription = description;
        return this;
    }
    /**
     * Adds a toggle.
     */
    toggle(manipulator) {
        this.layerManipulators.push(...capsWordToggle(manipulator));
        return this;
    }
    /**
     * Adds a key that deactivates the Caps WORD mode.
     */
    escapeKey(key, mandatoryModifiers, optionalModifiers) {
        let escapeManipulator = (0, karabiner_ts_1.map)(key, mandatoryModifiers, optionalModifiers).to(key, mandatoryModifiers);
        this.layerManipulators.push(...capsWordOff(escapeManipulator.build()[0]));
        return this;
    }
    /**
     * Adds an escape key without an echo.
     *
     * Useful for keys like ⎋, where the echo would often be spurious, i.e.,
     * we only want to exit the Caps WORD mode, not some external mode.
     */
    escapePassthroughKey(key, mandatoryModifiers, optionalModifiers) {
        let escapeManipulator = (0, karabiner_ts_1.map)(key, mandatoryModifiers, optionalModifiers);
        this.layerManipulators.push(...capsWordOff(escapeManipulator.build()[0]));
        return this;
    }
    defaultEscapeKeys(use) {
        this.useDefaultEscapeKeys = use;
        return this;
    }
    build() {
        // Deactivators
        if (this.useDefaultEscapeKeys) {
            this.escapePassthroughKey("⎋")
                // It's important the ⇪ turns off the variable as well. Otherwise,
                // we might inadvertedly reenable ⇪ in some cases.
                .escapePassthroughKey("⇪")
                .escapeKey("⏎", undefined, "any")
                .escapeKey("␣")
                .escapeKey("l⇧", undefined, "any")
                .escapeKey("r⇧", undefined, "any")
                .escapeKey("0", "⇧", "any")
                .escapeKey("close_bracket", undefined, "any")
                .escapeKey(";", undefined, "any")
                .escapeKey("'", undefined, "any")
                .escapeKey(",", undefined, "any")
                .escapeKey(".", undefined, "any")
                .escapeKey("/", undefined, "any");
        }
        return (0, karabiner_ts_1.rule)(this.ruleDescription)
            .manipulators([...this.layerManipulators])
            .build();
    }
}
exports.CapsWordBuilder = CapsWordBuilder;
/**
 * A caps-word layer turns on capitalizing letters until an escape key (⎋, ␣, etc.) is pressed.
 *
 * This layer works by turning on ⇪ under the hood and registering escape keys.
 */
function capsWord() {
    return new CapsWordBuilder();
}
